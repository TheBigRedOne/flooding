PROVIDER ?= virtualbox

# Provider goal rewriting: allow `make kvm …` or `make vb …` without double execution
ifeq ($(firstword $(MAKECMDGOALS)),kvm)
  PROVIDER := libvirt
  override MAKECMDGOALS := $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS))
endif
ifeq ($(firstword $(MAKECMDGOALS)),vb)
  PROVIDER := virtualbox
  override MAKECMDGOALS := $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS))
endif

# Optional flag-like goal to disable tests: allow `make kvm all -disable_test`
ifneq ($(filter -disable_test,$(MAKECMDGOALS)),)
  DISABLE_TEST := 1
  override MAKECMDGOALS := $(filter-out -disable_test,$(MAKECMDGOALS))
endif

# Master Control Makefile

# --- Main Experiment Outputs ---
# These variables define the key result files generated by the analysis scripts.

# (R1) Service Disruption
BASELINE_DISRUPTION_PDF := results/baseline/disruption_times.pdf
SOLUTION_DISRUPTION_PDF := results/solution/disruption_times.pdf

# (R2) Unmet-Interest Ratio
BASELINE_LOSS_PDF := results/baseline/loss_comparison.pdf
SOLUTION_LOSS_PDF := results/solution/loss_comparison.pdf

# (R3) Flooding Overhead
BASELINE_OVERHEAD_PDF := results/baseline/overhead_timeseries.pdf
SOLUTION_OVERHEAD_PDF := results/solution/overhead_timeseries.pdf


# --- Paper Figure Dependencies ---
# These variables link the experiment outputs to the figures in the paper.
MAIN_TEX := paper/OptoFlood.tex

# Define final figure paths for the paper
BASELINE_DISRUPTION_FIGURE := paper/figures/baseline_disruption.pdf
SOLUTION_DISRUPTION_FIGURE := paper/figures/solution_disruption.pdf
BASELINE_LOSS_FIGURE       := paper/figures/baseline_loss.pdf
SOLUTION_LOSS_FIGURE       := paper/figures/solution_loss.pdf
BASELINE_OVERHEAD_FIGURE   := paper/figures/baseline_overhead.pdf
SOLUTION_OVERHEAD_FIGURE   := paper/figures/solution_overhead.pdf

# Group all figures needed for the paper
BASELINE_PAPER_FIGURES := $(BASELINE_DISRUPTION_FIGURE) $(BASELINE_LOSS_FIGURE) $(BASELINE_OVERHEAD_FIGURE)
SOLUTION_PAPER_FIGURES := $(SOLUTION_DISRUPTION_FIGURE) $(SOLUTION_LOSS_FIGURE) $(SOLUTION_OVERHEAD_FIGURE)

PAPER_PDF := paper/OptoFlood.pdf
STATIC_FIGURES := paper/figures/NLSR_Work_Flow.png \
                  paper/figures/Producer_Mobility_Problems.png \
                  paper/figures/Topology.png
ALL_FIGURES := $(STATIC_FIGURES) $(BASELINE_PAPER_FIGURES) $(SOLUTION_PAPER_FIGURES)

# Common application source files
APP_SRCS := experiment/app/producer.cpp \
            experiment/app/consumer.cpp \
            experiment/app/trust-schema.conf

# Experiment-specific source files
BASELINE_SRCS := experiment/baseline/Vagrantfile \
                experiment/baseline/Makefile
                
SOLUTION_SRCS := experiment/solution/Vagrantfile \
                experiment/solution/Makefile

# Common tools used by both experiments
TOOLS_SRCS := experiment/tool/exp.py \
             experiment/tool/plot_latency.py \
             experiment/tool/plot_loss.py \
             experiment/tool/plot_overhead.py

# Host-side plotting environment (for re-generating figures without re-running experiments)
VENV_DIR := experiment/tool/.venv
PYTHON   := $(VENV_DIR)/bin/python3

BASELINE_DIR := results/baseline
SOLUTION_DIR := results/solution
CSV_BASELINE := $(BASELINE_DIR)/consumer_capture.csv
CSV_SOLUTION := $(SOLUTION_DIR)/consumer_capture.csv

# Main target (set DISABLE_TEST=1 to skip tests)
DISABLE_TEST ?=
all: box experiment $(if $(DISABLE_TEST),,test) result paper

# High-level orchestration targets (provider must be set via `make kvm ...` or `make vb ...`)
.PHONY: box box-initial box-baseline box-solution experiment experiment-baseline experiment-solution result paper test

# Boxes
box-initial: box/initial/initial.$(PROVIDER).box

box-baseline: box/baseline/baseline.$(PROVIDER).box

box-solution: box/solution/solution.$(PROVIDER).box

# Build all boxes (initial + baseline + solution)
box: box-initial box-baseline box-solution

# Experiments (run inside VMs and pull back results)
experiment-baseline: results/.baseline_fetched

experiment-solution: results/.solution_fetched

# Run both experiments
experiment: experiment-baseline experiment-solution

# Assemble result figures for the paper (copy from results/ to paper/figures)
result: $(BASELINE_PAPER_FIGURES) $(SOLUTION_PAPER_FIGURES)

# Run the test experiment
test: $(MAKE) -C test PROVIDER=$(PROVIDER) test-all

# Build the paper PDF (standalone: do not auto-run results)
paper:
	@missing=0; \
	for f in $(BASELINE_PAPER_FIGURES) $(SOLUTION_PAPER_FIGURES); do \
	  if [ ! -f $$f ]; then echo "Missing figure: $$f (run 'make $(PROVIDER) result')"; missing=1; fi; \
	done; \
	if [ $$missing -ne 0 ]; then exit 1; fi
	$(MAKE) -C paper

# Ensure results directories exist
results:
	mkdir $@

results/baseline: | results
	mkdir $@

results/solution: | results
	mkdir $@

paper/figures:
	mkdir $@

# Boxes check
box/initial/initial.$(PROVIDER).box: box/initial/Vagrantfile
	# incase previous attempt did not clean up properly
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial vagrant destroy -f
	-rm -f $@
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial vagrant up --provision
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial vagrant package --output $@
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial vagrant halt
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial vagrant destroy -f

box/baseline/baseline.$(PROVIDER).box: box/baseline/Vagrantfile box/initial/initial.$(PROVIDER).box
	# incase previous attempt did not clean up properly
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant destroy -f
	-rm -f $@
	ACTUAL_INITIAL_BOX_PATH="box/initial/initial.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant up --provision
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant package --output $@
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant halt
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant destroy -f

box/solution/solution.$(PROVIDER).box: box/solution/Vagrantfile box/initial/initial.$(PROVIDER).box
	# incase previous attempt did not clean up properly
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant destroy -f
	-rm -f $@
	ACTUAL_INITIAL_BOX_PATH="box/initial/initial.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant up --provision
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant package --output $@
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant halt
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant destroy -f

# Updated build-boxes target to reflect provider-specific boxes (kept for backward compatibility)
build-boxes: box-baseline box-solution

# SSH config file for baseline experiment
.ssh_config_baseline: experiment/baseline/Vagrantfile
	@if [ ! -f box/baseline/baseline.$(PROVIDER).box ]; then \
	  echo "Missing baseline box: box/baseline/baseline.$(PROVIDER).box"; \
	  echo "Please run 'make $(PROVIDER) box-baseline' (requires initial box)."; exit 1; \
	fi
	# Force destroy any lingering VM to ensure a clean state
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant destroy -f || true
	ACTUAL_BASELINE_BOX_PATH="box/baseline/baseline.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant up
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant ssh-config --host baseline > .ssh_config_baseline

# SSH config file for solution experiment
.ssh_config_solution: experiment/solution/Vagrantfile
	@if [ ! -f box/solution/solution.$(PROVIDER).box ]; then \
	  echo "Missing solution box: box/solution/solution.$(PROVIDER).box"; \
	  echo "Please run 'make $(PROVIDER) box-solution' (requires initial box)."; exit 1; \
	fi
	# Force destroy any lingering VM to ensure a clean state
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant destroy -f || true
	ACTUAL_SOLUTION_BOX_PATH="box/solution/solution.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant up
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant ssh-config --host solution > .ssh_config_solution

# Rsync commands
RSYNC_BASELINE = rsync -avH -e "ssh -F .ssh_config_baseline"
RSYNC_SOLUTION = rsync -avH -e "ssh -F .ssh_config_solution"

# Define all expected result files from one experiment run
BASELINE_RESULTS := $(BASELINE_DISRUPTION_PDF) \
                    results/baseline/disruption_metrics.txt \
                    $(BASELINE_LOSS_PDF) \
                    results/baseline/loss_ratio.txt \
                    $(BASELINE_OVERHEAD_PDF) \
                    results/baseline/overhead_total.txt

SOLUTION_RESULTS := $(SOLUTION_DISRUPTION_PDF) \
                    results/solution/disruption_metrics.txt \
                    $(SOLUTION_LOSS_PDF) \
                    results/solution/loss_ratio.txt \
                    $(SOLUTION_OVERHEAD_PDF) \
                    results/solution/overhead_total.txt

# Fetch baseline artifacts (pcap/csv/pdfs) from VM
results/.baseline_fetched: $(APP_SRCS) $(BASELINE_SRCS) $(TOOLS_SRCS) .ssh_config_baseline | results/baseline
	ACTUAL_BASELINE_BOX_PATH="box/baseline/baseline.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant up
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant ssh -c 'cd /home/vagrant/mini-ndn/flooding/experiment/baseline && make clean && make all'
	$(RSYNC_BASELINE) baseline:/home/vagrant/mini-ndn/flooding/experiment/baseline/results/ results/baseline
	@touch $@
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant halt -f || true

# Fetch solution artifacts (pcap/csv/pdfs) from VM
results/.solution_fetched: $(APP_SRCS) $(SOLUTION_SRCS) $(TOOLS_SRCS) .ssh_config_solution | results/solution
	ACTUAL_SOLUTION_BOX_PATH="box/solution/solution.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant up
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant ssh -c 'cd /home/vagrant/mini-ndn/flooding/experiment/solution && make clean && make all'
	$(RSYNC_SOLUTION) solution:/home/vagrant/mini-ndn/flooding/experiment/solution/results/ results/solution;
	@touch $@
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant halt -f || true

# Host-side venv for plotting
$(VENV_DIR): experiment/tool/requirements.txt
	python3 -m venv $(VENV_DIR)
	$(VENV_DIR)/bin/pip install -r experiment/tool/requirements.txt
	touch $(VENV_DIR)

# Replot from existing CSV (baseline)
$(BASELINE_DISRUPTION_PDF) $(BASELINE_DIR)/disruption_metrics.txt: $(CSV_BASELINE) experiment/tool/plot_latency.py | $(VENV_DIR) $(BASELINE_DIR)
	@if [ ! -f $(CSV_BASELINE) ]; then \
	  echo "Missing $(CSV_BASELINE). Please run 'make $(PROVIDER) experiment-baseline' first."; exit 1; \
	fi
	$(PYTHON) experiment/tool/plot_latency.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"

$(BASELINE_LOSS_PDF) $(BASELINE_DIR)/loss_ratio.txt: $(CSV_BASELINE) experiment/tool/plot_loss.py | $(VENV_DIR) $(BASELINE_DIR)
	@if [ ! -f $(CSV_BASELINE) ]; then \
	  echo "Missing $(CSV_BASELINE). Please run 'make $(PROVIDER) experiment-baseline' first."; exit 1; \
	fi
	$(PYTHON) experiment/tool/plot_loss.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"

$(BASELINE_OVERHEAD_PDF) $(BASELINE_DIR)/overhead_total.txt: $(CSV_BASELINE) experiment/tool/plot_overhead.py | $(VENV_DIR) $(BASELINE_DIR)
	@if [ ! -f $(CSV_BASELINE) ]; then \
	  echo "Missing $(CSV_BASELINE). Please run 'make $(PROVIDER) experiment-baseline' first."; exit 1; \
	fi
	$(PYTHON) experiment/tool/plot_overhead.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"

# Replot from existing CSV (solution)
$(SOLUTION_DISRUPTION_PDF) $(SOLUTION_DIR)/disruption_metrics.txt: $(CSV_SOLUTION) experiment/tool/plot_latency.py | $(VENV_DIR) $(SOLUTION_DIR)
	@if [ ! -f $(CSV_SOLUTION) ]; then \
	  echo "Missing $(CSV_SOLUTION). Please run 'make $(PROVIDER) experiment-solution' first."; exit 1; \
	fi
	$(PYTHON) experiment/tool/plot_latency.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

$(SOLUTION_LOSS_PDF) $(SOLUTION_DIR)/loss_ratio.txt: $(CSV_SOLUTION) experiment/tool/plot_loss.py | $(VENV_DIR) $(SOLUTION_DIR)
	@if [ ! -f $(CSV_SOLUTION) ]; then \
	  echo "Missing $(CSV_SOLUTION). Please run 'make $(PROVIDER) experiment-solution' first."; exit 1; \
	fi
	$(PYTHON) experiment/tool/plot_loss.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

$(SOLUTION_OVERHEAD_PDF) $(SOLUTION_DIR)/overhead_total.txt: $(CSV_SOLUTION) experiment/tool/plot_overhead.py | $(VENV_DIR) $(SOLUTION_DIR)
	@if [ ! -f $(CSV_SOLUTION) ]; then \
	  echo "Missing $(CSV_SOLUTION). Please run 'make $(PROVIDER) experiment-solution' first."; exit 1; \
	fi
	$(PYTHON) experiment/tool/plot_overhead.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

# (No phony CSV placeholders; missing CSV is handled by recipe-time checks with clear guidance.)

# --- Copy Results to Paper Directory ---
# These rules copy the final PDF results into the paper's figures directory.

$(BASELINE_DISRUPTION_FIGURE): $(BASELINE_DISRUPTION_PDF) | paper/figures
	cp $(BASELINE_DISRUPTION_PDF) $@

$(BASELINE_LOSS_FIGURE): $(BASELINE_LOSS_PDF) | paper/figures
	cp $(BASELINE_LOSS_PDF) $@

$(BASELINE_OVERHEAD_FIGURE): $(BASELINE_OVERHEAD_PDF) | paper/figures
	cp $(BASELINE_OVERHEAD_PDF) $@

$(SOLUTION_DISRUPTION_FIGURE): $(SOLUTION_DISRUPTION_PDF) | paper/figures
	cp $(SOLUTION_DISRUPTION_PDF) $@

$(SOLUTION_LOSS_FIGURE): $(SOLUTION_LOSS_PDF) | paper/figures
	cp $(SOLUTION_LOSS_PDF) $@

$(SOLUTION_OVERHEAD_FIGURE): $(SOLUTION_OVERHEAD_PDF) | paper/figures
	cp $(SOLUTION_OVERHEAD_PDF) $@

# Generate the paper
$(PAPER_PDF): $(MAIN_TEX) $(ALL_FIGURES) | paper
	$(MAKE) -C paper


# Cleanup
clean: clean-ssh-config
	rm -rf results
	cd paper && $(MAKE) clean

# Unified deep-clean (use with provider wrapper: `make kvm deep-clean` or `make vb deep-clean`)
deep-clean: _deep-clean_provider

# Renamed target for actual implementation
_deep-clean_provider: clean
	rm -rf $(BASELINE_FIGURE) $(SOLUTION_FIGURE) $(PAPER_PDF)
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial  vagrant destroy -f || true
	vagrant box remove box/baseline/baseline.$(PROVIDER).box || true
	vagrant box remove box/solution/solution.$(PROVIDER).box || true
	vagrant box remove box/initial/initial.$(PROVIDER).box || true
	rm -f box/baseline/baseline.$(PROVIDER).box
	rm -f box/solution/solution.$(PROVIDER).box
	rm -f box/initial/initial.$(PROVIDER).box


# Clean SSH config file
clean-ssh-config:
	rm -f .ssh_config_baseline .ssh_config_solution

# Provider-specific convenience targets
# Legacy provider convenience targets (kept for compatibility). No-op due to goal rewriting above.
kvm:
	@true

vb:
	@true

deep-clean-kvm:
	@echo "Deep cleaning using libvirt (KVM) provider..."
	@$(MAKE) PROVIDER=libvirt _deep-clean_provider

deep-clean-vb:
	@echo "Deep cleaning using VirtualBox provider..."
	@$(MAKE) PROVIDER=virtualbox _deep-clean_provider

.PHONY: all build-boxes clean deep-clean _deep-clean_provider clean-ssh-config kvm vb deep-clean-kvm deep-clean-vb box box-initial box-baseline box-solution experiment experiment-baseline experiment-solution result paper

.DELETE_ON_ERROR:

.NOTINTERMEDIATE:
