# =============================================================================
# Options to control the build

# By default, running Vagrant will use the virtualbox provider. To use the
# libvirt provider with KVM, add PROVIDER=libvirt to the make invocation.

PROVIDER ?= virtualbox

# By default, tests are run to demonstrate that the flooding mechanisms is
# working. To disable the tests, add DISABLE_TEST=1 to the make invocation.

DISABLE_TEST ?=

# Example invocations:
#    make                                  -- build using virtualbox
#    make PROVIDER=libvirt DISABLE_TEST=1  -- build using KVM without tests
#    make PROVIDER=libvirt deep-clean      -- deep-clean using KVM

export PROVIDER
export DISABLE_TEST

# =============================================================================
# Master Control Makefile

BOXES = box/initial/initial.$(PROVIDER).box \
        box/baseline/baseline.$(PROVIDER).box \
        box/solution/solution.$(PROVIDER).box

# Temporarily export logs of all nodes.
MOBILITY_LOG_NODES ?= core agg1 agg2 acc1 acc2 acc3 acc4 acc5 acc6 producer consumer

# --- Main Experiment Outputs ---
# These variables define the key result files generated by the analysis scripts.

# (R1) Throughput
BASELINE_THROUGHPUT_PDF := results/baseline/throughput_timeseries.pdf
SOLUTION_THROUGHPUT_PDF := results/solution/throughput_timeseries.pdf

# (R2) Service Disruption
BASELINE_DISRUPTION_PDF := results/baseline/disruption_times.pdf
SOLUTION_DISRUPTION_PDF := results/solution/disruption_times.pdf

# (R3) Unmet-Interest Ratio
BASELINE_LOSS_PDF := results/baseline/loss_comparison.pdf
SOLUTION_LOSS_PDF := results/solution/loss_comparison.pdf

# (R4) Flooding Overhead
BASELINE_OVERHEAD_PDF := results/baseline/overhead_timeseries.pdf
SOLUTION_OVERHEAD_PDF := results/solution/overhead_timeseries.pdf

# --- Paper Figure Dependencies ---
# These variables link the experiment outputs to the figures in the paper.
MAIN_TEX := paper/OptoFlood.tex
PAPER_BIN := paper/bin
LATEXMK := latexmk
LATEXMK_FLAGS := -pdf -interaction=nonstopmode -output-directory=$(PAPER_BIN)

# Define final figure paths for the paper
BASELINE_DISRUPTION_FIGURE := paper/figures/baseline_disruption.pdf
SOLUTION_DISRUPTION_FIGURE := paper/figures/solution_disruption.pdf
BASELINE_LOSS_FIGURE       := paper/figures/baseline_loss.pdf
SOLUTION_LOSS_FIGURE       := paper/figures/solution_loss.pdf
BASELINE_OVERHEAD_FIGURE   := paper/figures/baseline_overhead.pdf
SOLUTION_OVERHEAD_FIGURE   := paper/figures/solution_overhead.pdf
BASELINE_THROUGHPUT_FIGURE := paper/figures/baseline_throughput.pdf
SOLUTION_THROUGHPUT_FIGURE := paper/figures/solution_throughput.pdf

# Group all figures needed for the paper
BASELINE_PAPER_FIGURES := $(BASELINE_DISRUPTION_FIGURE) $(BASELINE_LOSS_FIGURE) $(BASELINE_OVERHEAD_FIGURE) $(BASELINE_THROUGHPUT_FIGURE)
SOLUTION_PAPER_FIGURES := $(SOLUTION_DISRUPTION_FIGURE) $(SOLUTION_LOSS_FIGURE) $(SOLUTION_OVERHEAD_FIGURE) $(SOLUTION_THROUGHPUT_FIGURE)

PAPER_PDF := paper/OptoFlood.pdf
STATIC_FIGURES := paper/figures/NDN_Packets_Processing_Flow.pdf \
                  paper/figures/NDN_Producer_Mobility_Problem.pdf \
                  paper/figures/NDN_Producer_Mobility_Problem_Solution.pdf \
                  paper/figures/Topology.pdf
ALL_FIGURES := $(STATIC_FIGURES) $(BASELINE_PAPER_FIGURES) $(SOLUTION_PAPER_FIGURES)

# Common application source files
APP_SRCS := experiment/app/producer.cpp \
            experiment/app/consumer.cpp \
            experiment/app/trust-schema.conf

# Experiment-specific source files
BASELINE_SRCS := experiment/baseline/Vagrantfile \
                experiment/baseline/Makefile
                
SOLUTION_SRCS := experiment/solution/Vagrantfile \
                experiment/solution/Makefile

# Common tools used by both experiments
TOOLS_SRCS := experiment/tool/exp.py \
             experiment/tool/plot_latency.py \
             experiment/tool/plot_loss.py \
             experiment/tool/plot_overhead.py \
             experiment/tool/plot_throughput.py

# Host-side plotting environment (for re-generating figures without re-running experiments)
VENV_DIR := experiment/tool/.venv
PYTHON   := $(VENV_DIR)/bin/python3

BASELINE_DIR := results/baseline
SOLUTION_DIR := results/solution
CSV_BASELINE := $(BASELINE_DIR)/consumer_capture.csv
CSV_SOLUTION := $(SOLUTION_DIR)/consumer_capture.csv
TEST_VALIDATE_OK := test/.validate_ok
TEST_SRCS := test/Makefile test/Vagrantfile test/exp_test.py test/validate.py \
             experiment/app/producer.cpp experiment/app/consumer.cpp \
             experiment/app/trust-schema.conf experiment/tool/ndn.lua

# Main target (set DISABLE_TEST=1 to skip tests)
DISABLE_TEST ?=
all: $(BOXES) experiment $(if $(DISABLE_TEST),,$(TEST_VALIDATE_OK)) result paper

# High-level orchestration targets (provider must be set via `make kvm ...` or `make vb ...`)
.PHONY: boxes experiment experiment-baseline experiment-solution result plot paper test mypy vm-clean


# Experiments (run inside VMs and pull back CSVs)
experiment-baseline: $(CSV_BASELINE)

experiment-solution: $(CSV_SOLUTION)

# Run both experiments
experiment: experiment-baseline experiment-solution

# Assemble result figures for the paper (copy from results/ to paper/figures)
result: $(BASELINE_PAPER_FIGURES) $(SOLUTION_PAPER_FIGURES)

# Run the test experiment
test: $(TEST_VALIDATE_OK)

$(TEST_VALIDATE_OK): $(TEST_SRCS) box/solution/solution.$(PROVIDER).box
	$(MAKE) -C test PROVIDER=$(PROVIDER) test-all

# Plot only (reuse existing CSVs; no VM run)
plot: | $(VENV_DIR)
	@test -f $(CSV_BASELINE) || (echo "Missing CSV: $(CSV_BASELINE). Run 'make experiment-baseline' first." && exit 1)
	@test -f $(CSV_SOLUTION) || (echo "Missing CSV: $(CSV_SOLUTION). Run 'make experiment-solution' first." && exit 1)
	$(PYTHON) experiment/tool/plot_latency.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"
	$(PYTHON) experiment/tool/plot_loss.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"
	$(PYTHON) experiment/tool/plot_overhead.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"
	$(PYTHON) experiment/tool/plot_throughput.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"
	$(PYTHON) experiment/tool/plot_latency.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"
	$(PYTHON) experiment/tool/plot_loss.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"
	$(PYTHON) experiment/tool/plot_overhead.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"
	$(PYTHON) experiment/tool/plot_throughput.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

# Build the paper PDF (follow dependencies; do not hand-check and exit)
paper: $(PAPER_PDF)

# Ensure results directories exist
results:
	mkdir $@

results/baseline: | results
	mkdir $@

results/solution: | results
	mkdir $@

paper/figures:
	mkdir $@

# Type checking (mypy) using host venv
mypy: | $(VENV_DIR)
	$(PYTHON) -m mypy --config-file mypy.ini test/validate.py experiment/tool/plot_throughput.py experiment/tool/plot_latency.py experiment/tool/plot_loss.py experiment/tool/plot_overhead.py


# =============================================================================
# Rules to build the Vagrant boxes

boxes: $(BOXES)

box/initial/initial.$(PROVIDER).box: box/initial/Vagrantfile
	PROVIDER=$(PROVIDER) sh scripts/make-box.sh $(dir $<) $@

box/baseline/baseline.$(PROVIDER).box: box/baseline/Vagrantfile box/initial/initial.$(PROVIDER).box
	PROVIDER=$(PROVIDER) sh scripts/make-box.sh $(dir $<) $@

box/solution/solution.$(PROVIDER).box: box/solution/Vagrantfile box/initial/initial.$(PROVIDER).box
	PROVIDER=$(PROVIDER) sh scripts/make-box.sh $(dir $<) $@


# =============================================================================


# SSH config file for baseline experiment
.ssh_config_baseline: experiment/baseline/Vagrantfile box/baseline/baseline.$(PROVIDER).box
	# Force destroy any lingering VM to ensure a clean state
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant destroy -f || true
	ACTUAL_BASELINE_BOX_PATH="box/baseline/baseline.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant up --provision
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant ssh-config --host baseline > .ssh_config_baseline

# SSH config file for solution experiment
.ssh_config_solution: experiment/solution/Vagrantfile box/solution/solution.$(PROVIDER).box
	# Force destroy any lingering VM to ensure a clean state
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant destroy -f || true
	ACTUAL_SOLUTION_BOX_PATH="box/solution/solution.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant up --provision
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant ssh-config --host solution > .ssh_config_solution

# Rsync commands
RSYNC_BASELINE = rsync -avH -e "ssh -F .ssh_config_baseline"
RSYNC_SOLUTION = rsync -avH -e "ssh -F .ssh_config_solution"

# Remote working directory inside VMs (standardized for rsync-based runs)
REMOTE_DIR := /home/vagrant/flooding

# Files/dirs excluded from rsync push
RSYNC_EXCLUDES := \
  --exclude .git \
  --exclude .vagrant \
  --exclude results \
  --exclude paper/bin


# Baseline: build CSV via one VM run, then host will plot PDFs from CSV
$(CSV_BASELINE): $(APP_SRCS) $(BASELINE_SRCS) $(TOOLS_SRCS) .ssh_config_baseline | results/baseline
	ACTUAL_BASELINE_BOX_PATH="box/baseline/baseline.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant up --provision
	$(RSYNC_BASELINE) $(RSYNC_EXCLUDES) ./ baseline:$(REMOTE_DIR)/
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant ssh -c 'set -e; \
	cd $(REMOTE_DIR)/experiment/baseline && make clean && make all; \
	mkdir -p results/minindn-logs; \
	if [ -d /tmp/minindn ]; then \
	  for name in $(MOBILITY_LOG_NODES); do \
	    node="/tmp/minindn/$$name"; \
	    if [ -d "$$node/log" ]; then \
	      mkdir -p "results/minindn-logs/$$name"; \
	      cp -f "$$node/log/nfd.log" "results/minindn-logs/$$name/" 2>/dev/null || true; \
	      cp -f "$$node/log/nlsr.log" "results/minindn-logs/$$name/" 2>/dev/null || true; \
	    fi; \
	  done; \
	fi'
	$(RSYNC_BASELINE) baseline:$(REMOTE_DIR)/experiment/baseline/results/. results/baseline/
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant halt -f || true

# Solution: build CSV via one VM run, then host will plot PDFs from CSV
$(CSV_SOLUTION): $(APP_SRCS) $(SOLUTION_SRCS) $(TOOLS_SRCS) .ssh_config_solution | results/solution
	ACTUAL_SOLUTION_BOX_PATH="box/solution/solution.$(PROVIDER).box" \
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant up --provision
	$(RSYNC_SOLUTION) $(RSYNC_EXCLUDES) ./ solution:$(REMOTE_DIR)/
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant ssh -c 'set -e; \
	cd $(REMOTE_DIR)/experiment/solution && make clean && make all; \
	mkdir -p results/minindn-logs; \
	if [ -d /tmp/minindn ]; then \
	  for name in $(MOBILITY_LOG_NODES); do \
	    node="/tmp/minindn/$$name"; \
	    if [ -d "$$node/log" ]; then \
	      mkdir -p "results/minindn-logs/$$name"; \
	      cp -f "$$node/log/nfd.log" "results/minindn-logs/$$name/" 2>/dev/null || true; \
	      cp -f "$$node/log/nlsr.log" "results/minindn-logs/$$name/" 2>/dev/null || true; \
	    fi; \
	  done; \
	fi'
	$(RSYNC_SOLUTION) solution:$(REMOTE_DIR)/experiment/solution/results/. results/solution/
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant halt -f || true

# Host-side venv for plotting
$(VENV_DIR): experiment/tool/requirements.txt
	python3 -m venv $(VENV_DIR)
	$(VENV_DIR)/bin/pip install -r experiment/tool/requirements.txt
	touch $(VENV_DIR)

# Plot from CSV (baseline)
$(BASELINE_DISRUPTION_PDF) $(BASELINE_DIR)/disruption_metrics.txt &: $(CSV_BASELINE) experiment/tool/plot_latency.py | $(VENV_DIR) $(BASELINE_DIR)
	$(PYTHON) experiment/tool/plot_latency.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"

$(BASELINE_LOSS_PDF) $(BASELINE_DIR)/loss_ratio.txt &: $(CSV_BASELINE) experiment/tool/plot_loss.py | $(VENV_DIR) $(BASELINE_DIR)
	$(PYTHON) experiment/tool/plot_loss.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"

$(BASELINE_OVERHEAD_PDF) $(BASELINE_DIR)/overhead_total.txt &: $(CSV_BASELINE) experiment/tool/plot_overhead.py | $(VENV_DIR) $(BASELINE_DIR)
	$(PYTHON) experiment/tool/plot_overhead.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"

$(BASELINE_THROUGHPUT_PDF) $(BASELINE_DIR)/throughput_metrics.txt &: $(CSV_BASELINE) experiment/tool/plot_throughput.py | $(VENV_DIR) $(BASELINE_DIR)
	$(PYTHON) experiment/tool/plot_throughput.py --input $(CSV_BASELINE) --output-dir $(BASELINE_DIR) --handoff-times "120, 240"

# Plot from CSV (solution)
$(SOLUTION_DISRUPTION_PDF) $(SOLUTION_DIR)/disruption_metrics.txt &: $(CSV_SOLUTION) experiment/tool/plot_latency.py | $(VENV_DIR) $(SOLUTION_DIR)
	$(PYTHON) experiment/tool/plot_latency.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

$(SOLUTION_LOSS_PDF) $(SOLUTION_DIR)/loss_ratio.txt &: $(CSV_SOLUTION) experiment/tool/plot_loss.py | $(VENV_DIR) $(SOLUTION_DIR)
	$(PYTHON) experiment/tool/plot_loss.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

$(SOLUTION_OVERHEAD_PDF) $(SOLUTION_DIR)/overhead_total.txt &: $(CSV_SOLUTION) experiment/tool/plot_overhead.py | $(VENV_DIR) $(SOLUTION_DIR)
	$(PYTHON) experiment/tool/plot_overhead.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

$(SOLUTION_THROUGHPUT_PDF) $(SOLUTION_DIR)/throughput_metrics.txt &: $(CSV_SOLUTION) experiment/tool/plot_throughput.py | $(VENV_DIR) $(SOLUTION_DIR)
	$(PYTHON) experiment/tool/plot_throughput.py --input $(CSV_SOLUTION) --output-dir $(SOLUTION_DIR) --handoff-times "120, 240"

# --- Copy Results to Paper Directory ---

$(BASELINE_DISRUPTION_FIGURE): $(BASELINE_DISRUPTION_PDF) | paper/figures
	cp $(BASELINE_DISRUPTION_PDF) $@

$(BASELINE_LOSS_FIGURE): $(BASELINE_LOSS_PDF) | paper/figures
	cp $(BASELINE_LOSS_PDF) $@

$(BASELINE_OVERHEAD_FIGURE): $(BASELINE_OVERHEAD_PDF) | paper/figures
	cp $(BASELINE_OVERHEAD_PDF) $@

$(BASELINE_THROUGHPUT_FIGURE): $(BASELINE_THROUGHPUT_PDF) | paper/figures
	cp $(BASELINE_THROUGHPUT_PDF) $@

$(SOLUTION_DISRUPTION_FIGURE): $(SOLUTION_DISRUPTION_PDF) | paper/figures
	cp $(SOLUTION_DISRUPTION_PDF) $@

$(SOLUTION_LOSS_FIGURE): $(SOLUTION_LOSS_PDF) | paper/figures
	cp $(SOLUTION_LOSS_PDF) $@

$(SOLUTION_OVERHEAD_FIGURE): $(SOLUTION_OVERHEAD_PDF) | paper/figures
	cp $(SOLUTION_OVERHEAD_PDF) $@

$(SOLUTION_THROUGHPUT_FIGURE): $(SOLUTION_THROUGHPUT_PDF) | paper/figures
	cp $(SOLUTION_THROUGHPUT_PDF) $@

# Generate the paper
$(PAPER_PDF): $(MAIN_TEX) $(ALL_FIGURES) | $(PAPER_BIN)
	@echo "Compiling LaTeX with latexmk..."
	$(LATEXMK) $(LATEXMK_FLAGS) $(MAIN_TEX)
	cp $(PAPER_BIN)/$(notdir $(PAPER_PDF)) $(PAPER_PDF)

$(PAPER_BIN):
	mkdir -p $(PAPER_BIN)


# Cleanup
clean: clean-ssh-config
	rm -rf results
	rm -rf $(VENV_DIR)
	$(LATEXMK) -c $(MAIN_TEX)
	rm -f $(PAPER_PDF)
	rm -rf $(PAPER_BIN)
	# remove copied paper figures
	rm -f $(BASELINE_PAPER_FIGURES) $(SOLUTION_PAPER_FIGURES)
	# remove test artifacts on host
	rm -rf test/pcap test/results
	rm -f test/consumer test/producer test/*.txt test/*.conf test/.ssh_config_solution \
	      test/.validate_ok test/.sync_solution_*

deep-clean: clean
	rm -rf $(BASELINE_FIGURE) $(SOLUTION_FIGURE) $(PAPER_PDF)
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=test vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial  vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) vagrant box remove box/baseline/baseline.$(PROVIDER).box || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) vagrant box remove box/solution/solution.$(PROVIDER).box || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) vagrant box remove box/initial/initial.$(PROVIDER).box || true
	rm -f box/baseline/baseline.$(PROVIDER).box
	rm -f box/solution/solution.$(PROVIDER).box
	rm -f box/initial/initial.$(PROVIDER).box

# Clean SSH config file
clean-ssh-config:
	rm -f .ssh_config_baseline .ssh_config_solution

# Destroy all VMs (keep boxes)
vm-clean: clean-ssh-config
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/baseline vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=experiment/solution vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=test vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/baseline vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/solution vagrant destroy -f || true
	VAGRANT_DEFAULT_PROVIDER=$(PROVIDER) VAGRANT_CWD=box/initial vagrant destroy -f || true


.PHONY: all build-boxes clean deep-clean clean-ssh-config box box-initial box-baseline box-solution experiment experiment-baseline experiment-solution result paper

.DELETE_ON_ERROR:

.NOTINTERMEDIATE:
